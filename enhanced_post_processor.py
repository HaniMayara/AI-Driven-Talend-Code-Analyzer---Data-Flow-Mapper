#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Enhanced Post-Processor for JSON Output

This script provides robust post-processing capabilities for JSON outputs
generated by the fine-tuned model, including validation and template-based correction.
"""

import json
import re
import logging
import argparse
from pathlib import Path
from typing import Dict, Any, List, Tuple

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("post_processing.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class JSONPostProcessor:
    """Class for post-processing and validating JSON outputs."""
    
    def __init__(self, template_path: str = None):
        """
        Initialize the post-processor.
        
        Args:
            template_path: Path to a template JSON file to use for reference
        """
        self.template = None
        if template_path:
            template_file = Path(template_path)
            if template_file.exists():
                with open(template_file, 'r', encoding='utf-8') as f:
                    self.template = json.load(f)
                logger.info(f"Loaded template from {template_path}")
            else:
                logger.warning(f"Template file {template_path} not found")
        
        # Define JSON schema for validation
        self.json_schema = {
            "type": "object",
            "required": ["job_name", "input_components", "output_components", "processing_logic"],
            "properties": {
                "job_name": {"type": "string"},
                "job_version": {"type": "string"},
                "project_name": {"type": "string"},
                "author": {"type": "string"},
                "description": {"type": "string"},
                "input_components": {"type": "array"},
                "transformation_components": {"type": "array"},
                "output_components": {"type": "array"},
                "processing_logic": {"type": "object"},
                "data_structures": {"type": "object"}
            }
        }
    
    def process_json_text(self, text: str) -> Dict[str, Any]:
        """
        Process potentially malformed JSON text and return a valid JSON object.
        
        Args:
            text: The JSON text to process
            
        Returns:
            A valid JSON object
        """
        logger.info("Processing JSON text...")
        
        # Try direct parsing first
        try:
            json_obj = json.loads(text)
            logger.info("Successfully parsed JSON directly")
            return json_obj
        except json.JSONDecodeError as e:
            logger.warning(f"Failed to parse JSON directly: {str(e)}")
        
        # Step 1: Try to fix common JSON syntax issues
        fixed_text = self._fix_json_syntax(text)
        try:
            json_obj = json.loads(fixed_text)
            logger.info("Successfully parsed JSON after syntax fixing")
            return json_obj
        except json.JSONDecodeError as e:
            logger.warning(f"Failed to parse JSON after syntax fixing: {str(e)}")
        
        # Step 2: Template-based reconstruction
        logger.info("Attempting template-based reconstruction")
        return self._reconstruct_from_template(text)
    
    def _fix_json_syntax(self, text: str) -> str:
        """
        Fix common JSON syntax issues.
        
        Args:
            text: The JSON text to fix
            
        Returns:
            Fixed JSON text
        """
        logger.info("Fixing JSON syntax...")
        
        # Remove any text before the first '{' and after the last '}'
        start_idx = text.find('{')
        end_idx = text.rfind('}')
        
        if start_idx != -1 and end_idx != -1:
            text = text[start_idx:end_idx+1]
        
        # Fix unbalanced quotes
        quote_count = text.count('"')
        if quote_count % 2 != 0:
            # Find unbalanced quotes and fix them
            in_string = False
            fixed_text = ""
            for char in text:
                if char == '"':
                    in_string = not in_string
                fixed_text += char
            
            # If we end up still in a string, add a closing quote
            if in_string:
                fixed_text += '"'
            
            text = fixed_text
        
        # Fix missing commas between objects in arrays
        text = re.sub(r'\}\s*\{', '},{', text)
        
        # Fix trailing commas in objects and arrays
        text = re.sub(r',\s*\}', '}', text)
        text = re.sub(r',\s*\]', ']', text)
        
        # Balance brackets and braces
        open_braces = text.count('{')
        close_braces = text.count('}')
        open_brackets = text.count('[')
        close_brackets = text.count(']')
        
        # Add missing closing braces
        if open_braces > close_braces:
            text += '}' * (open_braces - close_braces)
        
        # Add missing closing brackets
        if open_brackets > close_brackets:
            text += ']' * (open_brackets - close_brackets)
        
        return text
    
    def _reconstruct_from_template(self, text: str) -> Dict[str, Any]:
        """
        Reconstruct a JSON object from a template, extracting as much information
        as possible from the malformed JSON text.
        
        Args:
            text: The malformed JSON text
            
        Returns:
            A reconstructed JSON object
        """
        # Start with a template based on the enhanced structure
        if self.template:
            template = self.template.copy()
        else:
            template = {
                "job_name": "",
                "job_version": "0.1",
                "project_name": "MIGRATION",
                "author": "user@talend.com",
                "description": "",
                "input_components": [],
                "transformation_components": [],
                "output_components": [],
                "processing_logic": {
                    "description": "",
                    "main_flow": "",
                    "error_handling": {
                        "component_error_handlers": [],
                        "error_logging": ""
                    }
                },
                "data_structures": {
                    "input": {}
                }
            }
        
        # Try to extract key information from the malformed JSON
        # Job name
        job_name_match = re.search(r'"job_name"\s*:\s*"([^"]+)"', text)
        if job_name_match:
            template["job_name"] = job_name_match.group(1)
        
        # Description
        desc_match = re.search(r'"description"\s*:\s*"([^"]+)"', text)
        if desc_match:
            template["description"] = desc_match.group(1)
        
        # Project name
        project_match = re.search(r'"project_name"\s*:\s*"([^"]+)"', text)
        if project_match:
            template["project_name"] = project_match.group(1)
        
        # Try to extract components
        # This is a simplified approach - a more sophisticated parser would be better
        component_pattern = r'\{\s*"component"\s*:\s*"([^"]+)"[^\}]*\}'
        component_matches = re.findall(component_pattern, text)
        
        # Categorize components based on naming patterns
        for comp_name in component_matches:
            comp = {"component": comp_name, "name": comp_name}
            
            if any(pattern in comp_name.lower() for pattern in ['input', 'source', 'read']):
                template["input_components"].append(comp)
            elif any(pattern in comp_name.lower() for pattern in ['output', 'target', 'write']):
                template["output_components"].append(comp)
            else:
                template["transformation_components"].append(comp)
        
        # Create main flow if components were found
        if any([template["input_components"], template["transformation_components"], template["output_components"]]):
            components = []
            if template["input_components"]:
                components.extend([comp["name"] for comp in template["input_components"]])
            if template["transformation_components"]:
                components.extend([comp["name"] for comp in template["transformation_components"]])
            if template["output_components"]:
                components.extend([comp["name"] for comp in template["output_components"]])
            
            template["processing_logic"]["main_flow"] = " â†’ ".join(components)
        
        logger.info("Created template-based JSON structure")
        return template
    
    def validate_json(self, json_obj: Dict[str, Any]) -> Tuple[bool, List[str]]:
        """
        Validate a JSON object against the expected schema.
        
        Args:
            json_obj: The JSON object to validate
            
        Returns:
            A tuple of (is_valid, issues)
        """
        issues = []
        
        # Check required fields
        for field in self.json_schema["required"]:
            if field not in json_obj:
                issues.append(f"Missing required field: {field}")
        
        # Check component arrays
        for component_type in ["input_components", "output_components", "transformation_components"]:
            if component_type in json_obj and not isinstance(json_obj[component_type], list):
                issues.append(f"{component_type} should be an array")
        
        # Check processing_logic structure
        if "processing_logic" in json_obj:
            if not isinstance(json_obj["processing_logic"], dict):
                issues.append("processing_logic should be an object")
            elif "main_flow" not in json_obj["processing_logic"]:
                issues.append("processing_logic should contain main_flow")
        
        is_valid = len(issues) == 0
        if is_valid:
            logger.info("JSON validation passed")
        else:
            logger.warning(f"JSON validation failed with {len(issues)} issues")
            for issue in issues:
                logger.warning(f"  - {issue}")
        
        return is_valid, issues

def main():
    """Main function to run the post-processor."""
    parser = argparse.ArgumentParser(description='Post-process and validate JSON output')
    parser.add_argument('--input_file', type=str, required=True,
                        help='Path to the input JSON file to process')
    parser.add_argument('--output_file', type=str, required=True,
                        help='Path to save the processed JSON')
    parser.add_argument('--template_file', type=str, default=None,
                        help='Path to a template JSON file to use for reference')
    
    args = parser.parse_args()
    
    # Check if input file exists
    input_file = Path(args.input_file)
    if not input_file.exists():
        logger.error(f"Input file {input_file} does not exist")
        return
    
    # Initialize post-processor
    post_processor = JSONPostProcessor(template_path=args.template_file)
    
    # Load input JSON text
    with open(input_file, 'r', encoding='utf-8') as f:
        input_text = f.read()
    
    # Process JSON
    processed_json = post_processor.process_json_text(input_text)
    
    # Validate JSON
    is_valid, issues = post_processor.validate_json(processed_json)
    
    # Save processed JSON
    output_file = Path(args.output_file)
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(processed_json, f, indent=2)
    
    logger.info(f"Processed JSON saved to {output_file}")
    
    return processed_json

if __name__ == "__main__":
    main()